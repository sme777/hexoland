function isJSONArray(e){return Array.isArray(e)}function isJSONObject(e){return e!==null&&typeof e==="object"&&(e.constructor===void 0||e.constructor.name==="Object")}function isJSONPatchOperation(e){return!(!e||typeof e!=="object")&&typeof e.op==="string"}function isJSONPatchAdd(e){return!(!e||typeof e!=="object")&&e.op==="add"}function isJSONPatchRemove(e){return!(!e||typeof e!=="object")&&e.op==="remove"}function isJSONPatchReplace(e){return!(!e||typeof e!=="object")&&e.op==="replace"}function isJSONPatchCopy(e){return!(!e||typeof e!=="object")&&e.op==="copy"}function isJSONPatchMove(e){return!(!e||typeof e!=="object")&&e.op==="move"}function isJSONPatchTest(e){return!(!e||typeof e!=="object")&&e.op==="test"}function isEqual(e,t){return JSON.stringify(e)===JSON.stringify(t)}function strictEqual(e,t){return e===t}function initial(e){return e.slice(0,e.length-1)}function last(e){return e[e.length-1]}
/**
 * Test whether array1 starts with array2
 * @param array1
 * @param array2
 * @param [isEqual] Optional function to check equality
 */function startsWith(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:strictEqual;if(e.length<t.length)return false;for(let n=0;n<t.length;n++)if(!r(e[n],t[n]))return false;return true}function isObjectOrArray(e){return typeof e==="object"&&e!==null}function shallowClone(e){if(isJSONArray(e)){const t=e.slice();Object.getOwnPropertySymbols(e).forEach((r=>{t[r]=e[r]}));return t}if(isJSONObject(e)){const t={...e};Object.getOwnPropertySymbols(e).forEach((r=>{t[r]=e[r]}));return t}return e}function applyProp(e,t,r){if(e[t]===r)return e;{const n=shallowClone(e);n[t]=r;return n}}function getIn(e,t){let r=e;let n=0;while(n<t.length){r=isJSONObject(r)?r[t[n]]:isJSONArray(r)?r[parseInt(t[n])]:void 0;n++}return r}
/**
 * helper function to replace a nested property in an object with a new value
 * without mutating the object itself.
 *
 * @param object
 * @param path
 * @param value
 * @param [createPath=false]
 *                    If true, `path` will be created when (partly) missing in
 *                    the object. For correctly creating nested Arrays or
 *                    Objects, the function relies on `path` containing number
 *                    in case of array indexes.
 *                    If false (default), an error will be thrown when the
 *                    path doesn't exist.
 * @return Returns a new, updated object or array
 */function setIn(t,r,n){let o=arguments.length>3&&arguments[3]!==void 0&&arguments[3];if(r.length===0)return n;const i=r[0];const s=setIn(t?t[i]:void 0,r.slice(1),n,o);if(isJSONObject(t)||isJSONArray(t))return applyProp(t,i,s);if(o){const t=e.test(i)?[]:{};t[i]=s;return t}throw new Error("Path does not exist")}const e=/^\d+$/;function updateIn(e,t,r){if(t.length===0)return r(e);if(!isObjectOrArray(e))throw new Error("Path doesn't exist");const n=t[0];const o=updateIn(e[n],t.slice(1),r);return applyProp(e,n,o)}function deleteIn(e,t){if(t.length===0)return e;if(!isObjectOrArray(e))throw new Error("Path does not exist");if(t.length===1){const r=t[0];if(r in e){const t=shallowClone(e);isJSONArray(t)&&t.splice(parseInt(r),1);isJSONObject(t)&&delete t[r];return t}return e}const r=t[0];const n=deleteIn(e[r],t.slice(1));return applyProp(e,r,n)}function insertAt(e,t,r){const n=t.slice(0,t.length-1);const o=t[t.length-1];return updateIn(e,n,(e=>{if(!Array.isArray(e))throw new TypeError("Array expected at path "+JSON.stringify(n));const t=shallowClone(e);t.splice(parseInt(o),0,r);return t}))}function transform(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[];const n=t(e,r);if(isJSONArray(n)){let e;for(let o=0;o<n.length;o++){const i=n[o];const s=transform(i,t,r.concat(o+""));if(s!==i){e||(e=shallowClone(n));e[o]=s}}return e||n}if(isJSONObject(n)){let e;for(const o in n)if(Object.hasOwnProperty.call(n,o)){const i=n[o];const s=transform(i,t,r.concat(o));if(s!==i){e||(e=shallowClone(n));e[o]=s}}return e||n}return n}function existsIn(e,t){return e!==void 0&&(t.length===0||e!==null&&existsIn(e[t[0]],t.slice(1)))}function parseJSONPointer(e){const t=e.split("/");t.shift();return t.map((e=>e.replace(/~1/g,"/").replace(/~0/g,"~")))}function compileJSONPointer(e){return e.map(compileJSONPointerProp).join("")}function compileJSONPointerProp(e){return"/"+String(e).replace(/~/g,"~0").replace(/\//g,"~1")}function appendToJSONPointer(e,t){return e+compileJSONPointerProp(t)}function startsWithJSONPointer(e,t){return e.startsWith(t)&&(e.length===t.length||e[t.length]==="/")}function immutableJSONPatch(e,t,r){let n=e;for(let e=0;e<t.length;e++){validateJSONPatchOperation(t[e]);let o=t[e];if(r&&r.before){const e=r.before(n,o);if(e!==void 0){e.document!==void 0&&(n=e.document);if(e.json!==void 0)throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');e.operation!==void 0&&(o=e.operation)}}const i=n;const s=parsePath(n,o.path);if(o.op==="add")n=add(n,s,o.value);else if(o.op==="remove")n=remove(n,s);else if(o.op==="replace")n=replace(n,s,o.value);else if(o.op==="copy")n=copy(n,s,parseFrom(o.from));else if(o.op==="move")n=move(n,s,parseFrom(o.from));else{if(o.op!=="test")throw new Error("Unknown JSONPatch operation "+JSON.stringify(o));test(n,s,o.value)}if(r&&r.after){const e=r.after(n,o,i);e!==void 0&&(n=e)}}return n}function replace(e,t,r){return setIn(e,t,r)}function remove(e,t){return deleteIn(e,t)}function add(e,t,r){return isArrayItem(e,t)?insertAt(e,t,r):setIn(e,t,r)}function copy(e,t,r){const n=getIn(e,r);if(isArrayItem(e,t))return insertAt(e,t,n);{const n=getIn(e,r);return setIn(e,t,n)}}function move(e,t,r){const n=getIn(e,r);const o=deleteIn(e,r);return isArrayItem(o,t)?insertAt(o,t,n):setIn(o,t,n)}function test(e,t,r){if(r===void 0)throw new Error(`Test failed: no value provided (path: "${compileJSONPointer(t)}")`);if(!existsIn(e,t))throw new Error(`Test failed: path not found (path: "${compileJSONPointer(t)}")`);const n=getIn(e,t);if(!isEqual(n,r))throw new Error(`Test failed, value differs (path: "${compileJSONPointer(t)}")`)}function isArrayItem(e,t){if(t.length===0)return false;const r=getIn(e,initial(t));return Array.isArray(r)}
/**
 * Resolve the path index of an array, resolves indexes '-'
 * @returns Returns the resolved path
 */function resolvePathIndex(e,t){if(last(t)!=="-")return t;const r=initial(t);const n=getIn(e,r);return r.concat(n.length)}function validateJSONPatchOperation(e){const t=["add","remove","replace","copy","move","test"];if(!t.includes(e.op))throw new Error("Unknown JSONPatch op "+JSON.stringify(e.op));if(typeof e.path!=="string")throw new Error('Required property "path" missing or not a string in operation '+JSON.stringify(e));if((e.op==="copy"||e.op==="move")&&typeof e.from!=="string")throw new Error('Required property "from" missing or not a string in operation '+JSON.stringify(e))}function parsePath(e,t){return resolvePathIndex(e,parseJSONPointer(t))}function parseFrom(e){return parseJSONPointer(e)}
/**
 * Create the inverse of a set of json patch operations
 * @param document
 * @param operations Array with JSON patch actions
 * @param [options]
 * @return Returns the operations to revert the changes
 */function revertJSONPatch(e,t,r){let n=[];const before=(e,t)=>{let o;const i=parsePath(e,t.path);if(t.op==="add")o=revertAdd(e,i);else if(t.op==="remove")o=revertRemove(e,i);else if(t.op==="replace")o=revertReplace(e,i);else if(t.op==="copy")o=revertCopy(e,i);else if(t.op==="move")o=revertMove(e,i,parseFrom(t.from));else{if(t.op!=="test")throw new Error("Unknown JSONPatch operation "+JSON.stringify(t));o=[]}let s;if(r&&r.before){const n=r.before(e,t,o);n&&n.revertOperations&&(o=n.revertOperations);n&&n.document&&(s=n.document);if(n&&n.json)throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"')}n=o.concat(n);if(s!==void 0)return{document:s}};immutableJSONPatch(e,t,{before:before});return n}function revertReplace(e,t){return[{op:"replace",path:compileJSONPointer(t),value:getIn(e,t)}]}function revertRemove(e,t){return[{op:"add",path:compileJSONPointer(t),value:getIn(e,t)}]}function revertAdd(e,t){return isArrayItem(e,t)||!existsIn(e,t)?[{op:"remove",path:compileJSONPointer(t)}]:revertReplace(e,t)}function revertCopy(e,t){return revertAdd(e,t)}function revertMove(e,t,r){if(t.length<r.length&&startsWith(r,t))return[{op:"replace",path:compileJSONPointer(t),value:e}];const n={op:"move",from:compileJSONPointer(t),path:compileJSONPointer(r)};return!isArrayItem(e,t)&&existsIn(e,t)?[n,...revertRemove(e,t)]:[n]}export{appendToJSONPointer,compileJSONPointer,compileJSONPointerProp,deleteIn,existsIn,getIn,immutableJSONPatch,insertAt,isJSONArray,isJSONObject,isJSONPatchAdd,isJSONPatchCopy,isJSONPatchMove,isJSONPatchOperation,isJSONPatchRemove,isJSONPatchReplace,isJSONPatchTest,parseFrom,parseJSONPointer,parsePath,revertJSONPatch,setIn,startsWithJSONPointer,transform,updateIn};

